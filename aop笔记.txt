使用aspectj框架实现aop
使用aop:目的是给已经存在的一些类和方法,增加额外的功能,提前是不改变原来的类的代码

使用aspectj实现aop的基本步骤:
简单说:加入依赖,
      配置文件(创建目标类,切面类,自动代理生成器),
        创建目标类,切面类后,遇到生成器:
            先到创建的对象中寻找@Aspects注解(哪个有注解哪个是切面类)
            在切面类中通过切面表达式指定目标类,和切面功能,执行位置
详细说:
1.新建maven项目
2.加入依赖
    1)spring依赖
    2)aspectj依赖
    3)junit单元测试
3.创建目标类:接口和他的实现类
  要做的是给类中的方法增加功能

4.创建切面类:普通类
  1)在类的上面加入 @Aspect
  2)在类中定义方法,方法就是切面要执行的功能代码
    在方法的上面加入aspect中的通知注解,例如@Before
    还需要指定切入点表达式execution()
5.创建spring的配置文件:声明对象,把对象交给容器统一管理
  声明对象你可以使用注解或xml配置文件<bean>
  1)声明目标对象
  2)声明切面类对象
  3)声明aspectj框架中的自动代理生成器标签
    自动代理生成器:用来完成代理对象的自动创建功能.
6.创建测试类,从spring容器中获取目标对象(实际就是代理对象)
  通过代理执行方法,实现aop的功能增强

复习:
动态代理:使用第三方工具,实现代理对象的创建
       要求:目标类必须能够继承,不能是final
       原理:代理就是继承,子类就是代理(切面类要能被继承,因为代理就是切面类的子类)
用在哪些地方:
    1.当你的源码功能不完善,需要加点功能又不能改变原代码时,可有动态代理
    2.当你要给多个类添加同一个功能时,可以动态代理
    3.给业务方法增加事物,日志输出

    ***如果有实现接口采用JDK动态代理***（Spring默认会选择JDK动态代理）
    【JDK动态代】：其代理对象必须是某个接口的实现类
    xml文件：<aop:aspectj-autoproxy proxy-target-class="false"/>
    ***如果没有实现接口采用cglib代理***
    【CGLIB代理】：性能比JDK强，不能覆盖final方法，在final前后加逻辑不行
    xml文件：<aop:aspectj-autoproxy proxy-target-class="true"/>

